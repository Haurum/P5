\chapter{Implementation}
\label{chap:Implementation}
This chapter will describe the implementation of the systems components. It will cover the description of the Microsoft Kinect, the robot's code and how the scheduling is done. 

\section{Microsoft Kinect}
\label{sec:Microsoft Kinect Implementation}

\section{Robot}
\label{sec:Robot}
This section will describe arduino code for the robot. This will include how the arduino connects to the Kinect and the robots behaviour and calculations done by the arduino. If there was any comments in the original code, they have been removed in the listings for this chapter. \newline
A problem occurred when both the WiFi shield and the motor shield should work together. When the WiFi shield is trying to connect to the network and if any of the motor shield components are initialized at the beginning of the program, it isn't possible to connect to the network. If it is connected to the network before the motor shield components are initialized, it is possible to receive data and use the motor shield components.

The arduino setup function, is a function run once at the beginning of the running program, to setup the program as the name implies. In listing \ref{lst:setup} the setup function is shown, which in this project will connect to the private network, using the guide from arduinos own website \citep{wg}. \newline
Basically it will try to connect to the specific network by passing the network name and password to the function WiFi.begin(), given by the WiFi library. If the arduino can't connect to the network "Couldn't get a wifi connection" will be printed to the console and it will exit the program with the while(true) loop. Else the arduino will call the function server.begin() and is now connected to the network.

\begin{lstlisting}[caption={The arduino setup function}, label={lst:setup}]
void setup() {
	Serial.begin(9600);           
	Serial.println("Attempting to connect to WPA network...");
	status = WiFi.begin(ssid, pass);

	if ( status != WL\_CONNECTED) { 
		Serial.println("Couldn't get a wifi connection");
		while(true);
	} 
	else {
		server.begin();
		Serial.println("Connected to network");
	}	
	ip = WiFi.localIP();
	Serial.println(ip);
}
\end{lstlisting}

The arduino loop function is where the arduino's behaviour is programmed, since it will loop over the code in this function. In listing \ref{lst:loop} lines 2-15, the arduino is to receive data from the Kinect. The boolean \textbf{shouldDrive} is initialized to false, therefore it will enter the first if-statement. The client will be initialized to server.available(), which will make the arduino ready to receive data. The if-statement at line 4 it will receive the data from the Kinect and append the chars to the string \textbf{dataString}, which will contains the coordinate set for the objects impact position. \newline
At the if-statement at line 10, it will get the goalX and goalY coordinates from the string \textbf{dataString} and convert them to integers. Then setting the boolean \textbf{shouldDrive} = true, and set the string \textbf{dataString} = "". \newline
Since \textbf{shouldDrive} is now true, it will enter the else-statement at line 16. Lines 17-33 are setting up the arduino to get ready to drive to the received coordinate point. First it will initialize the motors, setting the attaching the interrupts for the motor encoders, setting the motorspeed and releaseing the motors so it won't drive. Also it will initialized two new integers \textbf{leftTemp} and \textbf{rightTemp} to the value of the integers of \textbf{leftTotal} and \textbf{rightTotal} at the given time in the program.

\begin{lstlisting}[caption={The arduino loop function}, label={lst:loop}]
void loop() {
	if (!shouldDrive) {
		client = server.available();
		if (client.connected()){
			while (client.available()) {
			char c = client.read(); 
			dataString += c;
			}
		}
		if (dataString != "") {
			goalX = dataString.substring(0,dataString.indexOf(';')).toInt();
			goalY = dataString.substring(dataString.indexOf(';')+1).toInt();
			shouldDrive = true;
			dataString = "";
		}
	} else {
		AF_DCMotor motorLeft(1);
		AF_DCMotor motorRight(2);
		pinMode(LEFTENCODERPIN, INPUT);
		attachInterrupt(3, incrementLeft, CHANGE);
		pinMode(RIGHTENCODERPIN, INPUT);
		attachInterrupt(2, incrementRight, CHANGE);
		
		motorLeft.setSpeed(255);
		motorRight.setSpeed(255);			
		motorLeft.run(RELEASE);
		motorLeftRun = false;
		motorRight.run(RELEASE);
		motorRightRun = false;
		
		leftTemp = leftTotal;
		rightTemp = rightTotal;
		
		if(posX <= goalX + margin && posX >= goalX - margin && posY <= goalY + margin && posY >= goalY - margin){
			stopIfAtGoal();
		} else {
			driveTowardsGoal();  
		}
		delay(10);
		updatePosAndHead();
	}
}
\end{lstlisting}



\section{Scheduling}
\label{sec:Scheduling implementation}
To be able to schedule the systems functions(also called tasks), the worst-case execution time(WCET) have to be known for the individual functions. The first attempt was to count the clock cycles in the assembly file of the complied arduino code. It was known that the Arduino mega 2560 has 16000 clock cycles per millisecond, so it will be possible to calculate the time for the functions. The purpose was to count the clock cycles for the two functions driveTowardsGoal() and updatePosAndHead(), to make that a possibility many of the functions in the different libraries used also had to be counted, the results of this can be found in Appendix \ref{chap:Clock cycles}.

In the following list, the clock cycles counted of the two functions are shown:
\begin{itemize}
	\item driveTowardsGoal = \textbf{4185} + (13)* + (174 + (13)*)* + (231 + (13)*)* + (17)* + (8)* + (33 + (17)*)* + (7)* + (5)* + (290 + (5)*)*
	\item updatePosAndHead = \textbf{3560} + (11)* + (13)* + (7)* + (174 + (13)*)* + (231 + (13)*)* (10)* + (24)* + (17)* + (33 + (17)*)*
\end{itemize}
The bold number is the worst-case of clock cycles counted in the function. The numbers in parentheses are loops, which bound is unknown, therefore it is not possible to make a count the exact WCET by counting the clock cycles.

Since it was not possible to count the clock cycles from the assembly code, it was decided to use the tool Bound-T, which will calculate the WCET outputted with an output in clock cycles. \newline
Bound-T was not able to calculate the WCET for the code. When Bound-T gets to calculating the floats, it is failing. It can't set an upper bound for the floating point numbers' WCET.

To be able to work around the float issues with Bound-T, a library called AVRFIX made by Maximilian Rosenblattl and Andreas Wolf \citep{AVRFIX}. In the listings \ref{Update1} and \ref{Update2} a function written with the AVRFIX library and a function written normally for arduino can be compared. Be aware that the function in listing \ref{Update2} might not look exactly like this in the final code for the project. 

\begin{lstlisting}[caption={The function updatePosAndHead with AWRFIX library}, label={Update1}]
void updatePosAndHead(){
int currentLeft = leftTotal;
int currentRight = rightTotal;
fix_t distPrDeg = ftok(DISTPRDEGREE);
fix_t dltL = itok(currentLeft - leftTemp);
fix_t dltR = itok(currentRight - rightTemp);
fix_t deltaLeft = mulk(dltL, distPrDeg);
fix_t deltaRight = mulk(dltR, distPrDeg);
leftTemp = currentLeft;
rightTemp = currentRight;
fix_t deltaSum = deltaLeft + deltaRight;
fix_t dist = divk(deltaSum,ftok(2.0));
fix_t sinHeading = sink(heading);
posX += mulk(dist, sinHeading);
fix_t cosHeading = cosk(heading);
posY += mulk(dist, cosHeading);
fix_t rel = divk((deltaRight - deltaLeft),ftok(WHEELDIST));
heading += atank(rel);
}
\end{lstlisting}

\begin{lstlisting}[caption={The function updatePosAndHead from the Arduino IDE}, label={Update2}]
void updatePosAndHead(){
int currentLeft = leftTotal;
int currentRight = rightTotal;
double deltaLeft = (currentLeft - leftTemp) * DISTPRDEGREE;
double deltaRight = (currentRight - rightTemp) * DISTPRDEGREE;
leftTemp = currentLeft;
rightTemp = currentRight;
double dist = (deltaLeft + deltaRight) / 2.0;
posX += (dist * sin(heading));
posY += (dist * cos(heading));
heading += (atan((deltaRight - deltaLeft) / WHEELDIST));
}
\end{lstlisting}

The program was rewritten with the AVRFIX library and then using Bound-T again to calculate the worst-case execution time for the functions. The AVRFIX library came with a .txt file from the GitHub download, which included the clock cycles for the AVRFIX functions. \newline
The function updatePosAndHead() is calculated to use 3995 clock cycles, but when trying to calculate the function driveTowardsGoal() another problem occurred. When a division by 0 took place, the program will enter an infinite loop, making it impossible to set an upper bound on the WCET. With this problem it is not possible to calculate the WCET for driveTowardsPoint().

Because using the AVRFIX library with Bound-T also failed, the group decided to use the function micros() on the functions to measure the time spent on the function, run them several times and use highest result as WCET. Besides the functions updatePosAndHead() and dirveTowardsGoal() the WCET, when the Kinect program sends data till the arduino received it via the WiFi, was also measured. 

The WCET for the two functions and the time spent on sending data from the Kinect via wifi, using the Micros() function, is listed below:
\begin{itemize}
	\item updatePosAndHead = 1076 microseconds
	\item driveTowardsGoal = 732 microseconds
	\item WiFi = 8433 microseconds
\end{itemize}

These results will be used to make a schedulability analysis in the UPPAAL program, which will be described in the following chapter.
